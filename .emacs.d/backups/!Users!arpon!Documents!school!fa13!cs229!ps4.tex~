\input{preamble}

\title{CS 229, Problem Set 3} \author{Arpon Raksit} \date{26 Sep 2013}

\begin{document}
\maketitle \thispagestyle{fancy}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\update}{\mathbf{update}}
\newcommand{\query}{\mathbf{query}}

\prob{1}

\footnote{Collaborated with Martin Camacho, David Liu, and Aleksandar Makelov}We assume that we can store and do basic arithmetic on integers at
most $\max(m,n)$ in $O(1)$ spacetime. Recall that we have an algorithm
\textsc{CounterPointQuery} with parameter $\epsilon_0$ which answers
point queries on $x \in \R^n$ in an insertion streams
deterministically with error at most $\epsilon_0\|x\|_1$ using
$O(1/\epsilon_0)$ space and with $O(1)$ query and update time.

We can assume $n = 2^k$. Let $\epsilon_0 := \epsilon/(2k)$. We run $k$
\textsc{CounterPointQuery} algorithms, denoting their update and query
algorithms by $\update(\nu,-)$ and $\query(\nu,-)$, respectively, for
$1 \le \nu \le k$. We also initialise a counter $m := 0$. Then we
define $\update(-)$ and $\query$ for \textsc{ApproximateMedianQuery}
as follows.
\begin{itemize}
\item $\update(i)$:
  \begin{enumerate}
  \item let $m := m+1$
  \item for $1 \le \nu \le k$, call $\update(\nu, \lfloor i/2^\nu
    \rfloor)$.
  \end{enumerate}
\item $\query$:
  \begin{enumerate}
  \item let $w := 0$ and $j := 0$
  \item for $1 \le \nu < k$:
    \begin{enumerate}
    \item let $q := \query(\nu,j)$
    \item if $w + q < m/2$, let $w := w + q$ and $j := 2(j+1)$
    \item else, let $j := 2j$
    \end{enumerate}
  \item output $j$
  \end{enumerate}
\end{itemize}
Observe that $\update(-)$ and $\query$ each take $O(k) = O(\log(n))$
time and that the algorithm uses $O(k/\epsilon_0) =
O(\log^2(n)/\epsilon)$ space (to maintain each
\textsc{CounterPointQuery}).

Finally we analyse accuracy. Consider the value $w$ at step (3) of
$\query$. By the accuracy guarantee on $\query(\nu,-)$ for $1 \le \nu
< k$ we know that
\[
\textstyle{|w - m/2|, |w - \sum_{i=1}^j
x_i| \le k\epsilon_0\|x\|_1 = \epsilon m/2 \implies |m/2 - \sum_{i=1}^j
x_i| \le \epsilon m.}
\]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\dup}{\mathrm{dup}}

\prob{2}

From our stream $i_1,\ldots,i_{n+1}$ we define a turnstile stream $T$
on $x \in \R^n$ as follows.
\begin{enumerate}
\item Initialise $x_i := 0$.
\item Update $x_{i_j} := x_{i_j} + 1$ for $1 \le j \le n+1$.
\item Update $x_i := x_i - 1$ for $1 \le i \le n$.
\end{enumerate}
We run $k := \lg(1/\delta)$ independent $1/2$-error $\ell_1$ samplers
on $T$ and query each at the end of the stream. Denote their outputs
by $(i_\nu, \what x_\nu)$ for $1 \le \nu \le k$. If there exists $1
\le \nu \le k$ such that $\what x_\nu > 0$ then we let $i_\dup :=
i_\nu$ (the choice of such $\nu$ does not matter). Else we arbitrarily
let $i_\dup := 1$.

Let $D \subseteq [n]$ the set of duplicate elements of the original
stream $i_1,\ldots,i_{n+1}$. We claim that $\Pr(i_\dup \in D) \ge 1 -
\delta$ for suitable choice of $k$.  Note that the algorithm clearly
uses space $k \cdot S(n,1/2) \in O(S(n,1/2)\log(1/\delta))$. Thus once
we show the claim we are done.

\begin{lemma}
  Fix $1 \le \nu \le k$. Then:
  \begin{enumerate}
  \item $\Pr(i_\nu \in D) \ge 1/2$;
  \item $\hat x_\nu > 0 \iff i_\nu \in D$.
  \end{enumerate}
\end{lemma}

\begin{proof}
  Let $I := \{i_1,\ldots,i_{n+1}\}$ and $m := |I|$. Consider the state
  of $x$ at the end of the stream $T$: we have
  \[
  x_i \ge 1 \iff i \in D, \quad x_i = 0 \iff i \in I - D, \quad x_i =
  -1 \iff i \in [n] - I.
  \]
  It follows then by the properties of the $\ell_1$ sampler that
  \[
  \Pr(i_\nu \in D) = \sum_{i \in D} \frac{|x_i|}{\|x\|_1} =
  \frac{n+1-m}{(n+1-m)+(n-m)} = \frac{n-m+1}{2(n-m)+1} \ge
  \frac{n-m}{2(n-m)} = \frac 12,
  \]
  which proves (1). And moreover since we use $1/2$-error $\ell_1$
  samplers we have that
  \[
  i_\nu \in D \implies \what x_\nu \ge 1/2, \quad i_\nu \in I-D
  \implies \what x_\nu = 0, \quad i_\nu \in [n] - I \implies \what
  x_\nu \le -1/2,
  \]
  which proves (2).
\end{proof}

By (1) of the lemma and independence of the samplers,
\[
\Pr(i_\nu \notin D\text{ for }1 \le \nu \le k) < 2^{-k} < \delta.
\]
This together with (2) of the lemma implies that $\Pr(i_\dup \in D)
\ge 1 - \delta$, proving the claim.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\prob{3}

\begin{definition}
  Let $G = (V,E)$ be a graph. We define a modified graph $\Phi(G) =
  (\Phi(V),\Phi(E))$ as follows:
  \begin{itemize}
  \item $\Phi(V) := V_1 \amalg V_2$, where we have bijections $V \to
    V_1$ sending $v \mapsto v_1$ and $V \to V_2$ sending $v \mapsto
    v_2$.
  \item $\Phi(E) := \{(u_1,v_2), (u_2,v_1) \mid (u,v) \in E\}$.
  \end{itemize}
  Note that in the streaming model, an insertion of an edge $(u,v)$ to
  $E$ translates simply into an insertion of two edges $(u_1,v_2),
  (u_2,v_1)$ to $\Phi(E)$, and similarly for deletion.
\end{definition}

\begin{lemma}
  Suppose $G = (V,E)$ has $k$ connected components. Then $G$ is
  bipartite if and only if $\Phi(G)$ has $2k$ connected components.
\end{lemma}

\begin{proof}
  By definition of $\Phi$, it suffices to consider the case
  $k=1$. First assume $G$ is bipartite, so $V = X \amalg Y$. We
  claim that the components of $\Phi(G)$ are precisely
  \[
  \{x_1,y_2 \mid x \in X, y \in Y\} \quad\text{and}\quad \{x_2,y_1
  \mid x \in X, y \in Y\}.
  \]
  Let $x \in X$, $v \in V - \{x\}$. Since $G$ is assumed to be
  connected, there is a path from $x$ to $v$. By bipartiteness, this
  path must have odd length if $v \in Y$ and even length if $v \in
  X$. By construction of $\Phi(E)$ it follows that $\Phi(G)$ has
  precisely the above connected components.

  Now assume $G$ is not bipartite, so that $G$ has a cycle $v^1 \to
  v^2 \to \cdots \to v^r \to v^1$ with $r$ odd. Then in $\Phi(G)$ this
  becomes a cycle
  \begin{equation}
    \tag{$\dagger$}
    v^1_1 \to v^2_2 \to \cdots \to v^r_1 \to v^1_2 \to v^2_1 \to \cdots
    \to v^r_2 \to v^1_1.
  \end{equation}
  Let $u,v \in V$ and $i,j \in \{1,2\}$. By connectedness of $G$ there
  is a path from $u$ to $v^1$ and a path from $v^1$ to $v$. Thus in
  $\Phi(G)$ there is a path from $u_i$ to $v^1_{i'}$ and from
  $v^1_{j'}$ to $v_j$ for some $i',j' \in \{1,2\}$. But by $(\dagger)$
  there is a path from $v^1_{i'}$ to $v^1_{j'}$, hence a path from
  $u_i$ to $v_j$. Thus $\Phi(G)$ is connected.
\end{proof}

\footnote{Collaborated with Aleksandar Makelov}Now, in lecture we saw
an algorithm to compute the number of connected components of a
streaming graph $G$ on $[n]$ which uses $n \polylog(n)$ space and
fails with probability at most $1/6$.\footnote{Actually, we saw in
  lecture the algorithm fails with probability at most
  $1/\poly(n)$. However, we achieved this by repeating the vector
  support sub-algorithm $\log(n)$ times, and by instead repeating it
  $c \log(n)$ times we can achieve the $1/6$ probability bound.} We
independently run this algorithm on $G$ and the modified graph
$\Phi(G)$ (the stream for which is described above). Then by a union
bound, with probability at least $2/3$ the algorithm outputs $k, k'$
the correct number of connected components for $G,\Phi(G)$,
respectively. By the lemma, we can then test bipartiteness correctly
with probability at least $2/3$ by saying $G$ is bipartite if and only
if $k' = 2k$.

\end{document}
