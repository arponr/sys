\input{preamble}

\title{CS 229, Problem Set 2}
\author{Arpon Raksit}
\date{17 Sep 2013}

\begin{document}
\maketitle
\thispagestyle{fancy}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\prob{1}

\subprob{a}

Suppose we have $1 \le i,j \le N$ such that $|\{x \in \F_q \mid p_i(x)
= p_j(x)\}| > d$. Then $p_i - p_j$ has at least $d+1$ roots, but this
implies $p_i - p_j = 0$ since $\deg(p_i),\deg(p_j) \le d \implies
\deg(p_i) - \deg(p_j) \le d$; i.e., $i = j$. Thus we have $\alpha \le
d/q$.

\subprob{b}

We want $q^{d+1} =: N \ge n \iff (d+1)\log(q) \ge \log(n)$, and by (a)
if we choose $d := \epsilon q$ then $\alpha \le \epsilon$.

\begin{lem}
  Let $x, t \in \R$ with $t > 1$. If $x \ge 2t/\log(t)$ then $x\log(x)
  \ge t$.
\end{lem}

\begin{proof}
  Assuming $x \ge 2t/\log(t)$ we have
  \begin{align*}
    x\log(x) &\ge \frac{2t}{\log(t)} \left(\log(2) + \log(t) -
    \log(\log(t))\right) \ge 2t\left(1 -
    \frac{\log(\log(t))}{\log(t)}\right) > t,
  \end{align*}
  where the last inequality follows from the fact that $\log(a)/a <
  1/2$ for $a > 0$.
\end{proof}

By Lemma 1\footnote{Thomas Steinke suggested using this lemma to solve
  the problem.}, assuming $\epsilon^{-1}\log(n) > 1$, if we choose
\[
q := \frac{2\epsilon^{-1}\log(n)}{\log(\epsilon^{-1}\log(n))}
\]
we have $(d+1)\log(q) \ge \epsilon q\log(q) \ge \log(n)$, as desired.

With this choice of $d,q$ we have
\[
m = qt = q^2 = d^2/\epsilon^2 =
\frac{4\epsilon^{-2}\log^2(n)}{\log^2(\epsilon^{-1}\log(n))}.
\]

\subprob{c}

As stated in the problem, the random codes give $m = qt \in
O(\epsilon^{-2} \log(n))$. Therefore we need
\[
\frac{\log(n)}{\log^2(\epsilon^{-1}\log(n))} \in O(1) \iff \epsilon
\in O(e^{-\sqrt{\log(n)}}\log(n))
\]
for the bound in (b) to give smaller $m$ than the bound for random
codes stated above.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\prob{2}

\subprob{a}

It is evident that the result of $\mathbf{query}(i)$ in
\textsc{CounterPointQuery} is identical to the result of
$\mathbf{query}(i)$ in the following alternative algorithm.
\begin{enumerate}
\item Let $C_i$ for $i \in [n]$ counters initialised to $0$.
\item $\mathbf{update}(i)$:
  \begin{enumerate}
  \item If $|\{j \in [n] \mid C_j > 0\}| < k$ or $C_i > 0$, then set
    $C_i := C_i + 1$.
  \item Else, set $C_j := C_j - 1$ for all $j \in [n]$ for which $C_j
    > 0$.
  \end{enumerate}
\item $\mathbf{query}(i)$: Output $C_i$.
\end{enumerate}
From this formulation it is clear that an increment to $x_i$ is not
reflected in the output of $\mathbf{query}(i)$ precisely when a
decrement (2b) occurs on $\mathbf{update}(i)$ or when a decrement
occurs on $\mathbf{update}(j)$ for $j \in [n] - \{i\}$ when $C_i >
0$. I.e.,
\[
x_i - d \le \mathbf{query}(i) \le x_i,
\]
where $d$ is the number of decrements performed. Now observe that
whenever a decrement occurs in $\mathbf{update}(i)$, $\sum_{j=1}^n
C_j$ decreases by $k$, and we miss an increment to
$C_i$.\footnote{David Liu and Aleksandar Makelov reminded me that this
  extra increment is missed, which produces the $k+1$ in place of a
  $k$ in the following line.} Then since $\|x\|_1 = m$ it follows that
$d \le m/(k+1)$. Hence if $k \ge 1/\epsilon - 1$ we have $d \le
\epsilon\|x\|_1$ and thus $\mathbf{query}(i) \in [x_i -
  \epsilon\|x\|_1, x_i]$.

\subprob{b}

Suppose we have a family\footnote{Aleksandar Makelov and I spent quite
  a bit of time thinking about the existence of such a family, but
  came up with nothing. If we assume $n \in O(k)$ and use a universal
  hash family then these properties are clearly satisfied (e.g. linear
  functions mod a prime could be computed in constant time by our
  assumptions on arithmetic).} of hash functions $h : [n] \to [ck]$
such that:
\begin{itemize}
\item for randomly chosen $h$, the expected time for hash table
  operations using $h$ is $O(1)$; i.e., the expected number of keys
  sent to any bucket is $O(1)$;
\item each $h$ can be stored in $O(k)$ space.
\end{itemize}
Then in the algorithm we first randomly choose an $h$ from this family
to construct a hash table of size $ck$. Entries of the hash table are
elements of a (doubly linked) list of size $k$, each of which stores a
pair $(i_j, C_j)$. Then $\mathbf{update}(i)$ can be implemented as
follows.
\begin{enumerate}
\item To check if $i = i_j$ for some $j \in [k]$: perform a lookup in
  the hash table to check if the list contains an element of the form
  $(i, C)$.
\item To increment $C_j$: move $(i_j, C_j)$ to the head of the list
  and set $C_j := C_j + 1$.
\item To check if $C_j = 0$ for some $j \in [k]$: check if the tail of
  the list is of the form $(i_j, 0)$; if so, we set the element to
  $(i, 1)$ and move it to the head of the list.
\item To decrement all $C_j$ for which $C_j > 0$: simply iterate over
  the linked list.
\end{enumerate}
The only subtlety here is to observe that any zero counter must be at
the tail end of the list, since incremented counters are always moved
to the head.

By our assumptions on the hash table, (1--3) are expected $O(1)$ time
operations. Of course (4) is $O(k)$ time in the worst case, but since
we proved in (a) that at most $m/(k+1)$ decrements are performed, (4)
in fact has $O(1)$ amortised expected running time.\footnote{Martin
  Camacho and Aleksandar Makelov suggested the use of an amortised
  cost here.} Finally note that by assumption on our hash family, the
hash table (and linked list) use $O(k)$ space.

\end{document}
